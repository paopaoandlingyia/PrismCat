# PrismCat 中期构想

> 本文档承接《初期构想》，定义项目从 MVP 走向成熟产品的发展方向。  
> **核心原则**：保持本地优先的定位，但架构上为云端部署预留空间，不堵死任何一条路。

---

## 当前状态回顾

初期目标已基本达成：
- ✅ Host 路由 + 透明反代
- ✅ 请求/响应完整记录（含 SSE/Streaming）
- ✅ 敏感头脱敏 + Body 截断
- ✅ SQLite 本地持久化
- ✅ 现代化 Web UI（日志查看、过滤、详情）
- ✅ 上游路由可视化管理
- ✅ 多语言支持（中/英）

---

## 中期目标概览

```
┌─────────────────────────────────────────────────────────────┐
│                     中期发展三大方向                          │
├─────────────────┬─────────────────┬─────────────────────────┤
│   架构演进       │   功能完善       │   可用性提升             │
│   (为云铺路)     │   (核心能力)     │   (体验打磨)            │
├─────────────────┼─────────────────┼─────────────────────────┤
│ • 存储层抽象     │ • 请求重放       │ • 日志搜索增强           │
│ • 远程数据库支持  │ • 大 Blob 分离   │ • 导出功能              │
│ • 配置热更新     │ • 请求对比       │ • 快捷键                │
│ • 健康检查增强   │ • Token 统计     │ • 移动端适配            │
└─────────────────┴─────────────────┴─────────────────────────┘
```

---

## 一、架构演进：为云端部署铺路

> **目标**：保持本地 SQLite 作为默认选项，同时支持远程数据库，让用户可以"无痛"切换到云端部署。

### 1.1 存储层抽象

当前存储直接耦合 SQLite。需要引入 **Repository/Store 接口**，隔离具体实现：

```go
// 示例接口定义
type LogStore interface {
    Save(ctx context.Context, log *RequestLog) error
    Get(ctx context.Context, id string) (*RequestLog, error)
    List(ctx context.Context, filter LogFilter) ([]RequestLog, int, error)
    Delete(ctx context.Context, olderThan time.Time) error
}

type ConfigStore interface {
    GetUpstreams() map[string]UpstreamConfig
    SetUpstream(name string, config UpstreamConfig) error
    // ...
}
```

**实现优先级**：
1. `SQLiteLogStore`（当前，保持不变）
2. `PostgresLogStore`（云端首选，Supabase/RDS 友好）
3. `MySQLLogStore`（可选，覆盖更多场景）

### 1.2 配置存储与热更新

当前上游路由存储在 `config.yaml`，这对本地场景足够。但云端部署时：
- 多实例需要共享配置
- 修改配置不应重启服务

**中期方案**：
- 配置可选存储到数据库（`config` 表）
- 提供 `/api/config/reload` 端点或监听配置变更
- 本地模式保持 YAML 文件优先（向后兼容）

### 1.3 环境感知的默认值

通过环境变量区分运行模式：

```yaml
# 本地模式（默认）
PRISMCAT_MODE=local
# - 使用 SQLite
# - 配置读 config.yaml
# - UI 默认绑定 localhost

# 云端模式
PRISMCAT_MODE=cloud
# - 使用 DATABASE_URL 连接远程数据库
# - 配置从数据库读取
# - 需要认证（后续实现）
```

### 1.4 健康检查与可观测性

为云端部署（K8s、Docker Compose）做准备：

- `/healthz` - 存活检查（Liveness）
- `/readyz` - 就绪检查（Readiness），含数据库连接状态
- 可选：Prometheus metrics 端点 `/metrics`

---

## 二、功能完善：核心能力增强

### 2.1 请求重放（Replay）

**场景**：调试时想用相同的请求再打一次上游，观察不同的响应。

**实现要点**：
- UI 中增加「重放」按钮
- 后端新增 `/api/logs/:id/replay` 端点
- 使用原请求的 Method、Path、Headers、Body 重新发起请求
- 记录为新的日志条目，关联原始 ID（`replay_of` 字段）
- **安全考量**：敏感头（如 Authorization）需要用户手动补充或从安全存储获取

### 2.2 大 Blob 分离（内容寻址 + Blob Store）

**问题**：LLM 请求可能包含大量 base64 图片，直接存入数据库会导致：
- 数据库膨胀
- 查询变慢
- 内存压力

**解决方案**：内容寻址 + Blob 分离

```
┌─────────────────────────────────────────────────────────┐
│                    日志记录流程                          │
├─────────────────────────────────────────────────────────┤
│  1. 检测 Body 是否包含大型 base64 块                      │
│  2. 若存在，提取并计算 SHA256 哈希                        │
│  3. 将 Blob 存入独立存储（本地文件/S3/OSS）               │
│  4. 在 Body 中用哈希引用替换原始内容                      │
│     例如: {"image": "blob://sha256:abc123..."}          │
│  5. UI 展示时按需加载 Blob                               │
└─────────────────────────────────────────────────────────┘
```

**Blob Store 接口**：

```go
type BlobStore interface {
    Put(ctx context.Context, data []byte) (hash string, err error)
    Get(ctx context.Context, hash string) ([]byte, error)
    Exists(ctx context.Context, hash string) (bool, error)
}
```

**实现优先级**：
1. `FileBlobStore` - 本地文件系统（`./data/blobs/{hash[:2]}/{hash}`）
2. `S3BlobStore` - 云端对象存储（后续）

**阈值建议**：
- 单个 base64 块 > 100KB 时触发分离
- Body 总大小 > 1MB 时强制检测

### 2.3 请求对比（Diff）

**场景**：对比两次请求的差异，快速定位问题。

- 选择两条日志进行对比
- 高亮显示 Headers、Body 的差异
- 支持 JSON 结构化对比（非纯文本 diff）

### 2.4 Token 使用统计

**场景**：追踪 LLM API 的 Token 消耗，辅助成本分析。

- 解析 OpenAI 响应中的 `usage` 字段
- 汇总统计：按上游、按时间段、按模型
- UI 展示趋势图表

---

## 三、可用性提升：体验打磨

### 3.1 日志搜索增强

- **全文搜索**：支持在 Body 中搜索关键词
- **高级过滤**：
  - 状态码范围（2xx/4xx/5xx）
  - 延迟范围（> 1s）
  - 流式/非流式
  - 包含错误
- **保存筛选器**：常用过滤条件可保存为预设

### 3.2 导出功能

- 支持导出为 JSON/CSV
- 可选时间范围和过滤条件
- 大数据量时异步导出 + 下载链接

### 3.3 快捷键支持

- `↑/↓` - 在日志列表中快速切换
- `Enter` - 打开详情
- `Esc` - 关闭详情/弹窗
- `Ctrl+F` - 聚焦搜索框
- `R` - 刷新列表

### 3.4 移动端适配

- 响应式布局优化
- 日志列表简化视图
- 触摸手势支持

---

## 四、安全与认证（云端必备，本地可选）

> **原则**：本地模式默认无认证，云端模式强制认证。

### 4.1 认证方案（后续实现）

- **API Key**：简单场景，适合个人或小团队
- **OAuth2/OIDC**：企业场景，集成现有身份系统

### 4.2 UI 认证

- 简单密码保护（本地可选开启）
- Token-based 登录（云端模式）

### 4.3 数据隔离

- 云端多租户场景需要 `tenant_id` 隔离
- 本地单用户场景无需额外处理

---

## 五、开发优先级排序

```
P0 - 中期必须完成
├── 存储层抽象（LogStore 接口）
├── PostgreSQL 支持
└── 请求重放

P1 - 中期尽量完成
├── 大 Blob 分离（本地文件模式）
├── 高级搜索过滤
└── 导出功能

P2 - 有余力则做
├── Token 统计
├── 请求对比
└── 快捷键

P3 - 后期/云端阶段
├── S3 Blob Store
├── 认证系统
└── 多租户
```

---

## 六、不做的事情（边界明确）

❌ **不做 API Gateway 功能**：限流、熔断、负载均衡等交给专业网关  
❌ **不做 API Key 管理**：不代管用户的 OpenAI/Gemini Key  
❌ **不做计费系统**：只统计 Token，不做账单  
❌ **不做 SDK**：保持 HTTP 透传，调用方无需改代码

---

## 附录：数据库表结构演进参考

```sql
-- 新增字段（中期）
ALTER TABLE logs ADD COLUMN replay_of TEXT;           -- 重放来源
ALTER TABLE logs ADD COLUMN token_usage_prompt INT;   -- Prompt tokens
ALTER TABLE logs ADD COLUMN token_usage_completion INT; -- Completion tokens

-- Blob 引用表（可选，用于追踪）
CREATE TABLE blobs (
    hash TEXT PRIMARY KEY,
    size INTEGER NOT NULL,
    ref_count INTEGER DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

---

*最后更新: 2026-02-09*
